<html>

  <head>
    <title>
      lagrange_interp_nd
    </title>
  </head>

  <body bgcolor="#eeeeee" link="#cc0000" alink="#ff3300" vlink="#000055">

    <h1 align = "center">
      lagrange_interp_nd
    </h1>

    <hr>

    <p>
      <b>lagrange_interp_nd</b>,
      a MATLAB code which
      defines and evaluates the Lagrange polynomial p(x) 
      which interpolates a set of data depending on a M-dimensional argument
      that was evaluated on a product grid,
      so that p(x(i)) = z(i).
    </p>

    <p>
      The interpolation function requires that the data points defining the interpolant
      lie on a product grid [A1,B1]x[A2,B2]x...x[Am,Bm], to be defined
      by a vector AB of dimension (M,2).
    </p>

    <p>
      The interpolation function requires that the user supply a vector N_1D 
      of length M, which specifies the number or "order" of data points in 
      each dimension.  The number of points in the product grid will then 
      be the product of the entries in N_1D.
    </p>

    <p>
      (A second version of the interpolation function uses instead a vector IND of length M,
      which is interpreted as a set of "levels".  Each level corresponds in
      a simple way to the number of "order" of data points.  In particular,
      levels 0, 1, 2, 3, 4 correspond to 1, 3, 5, 9 and 17 points.  This
      version is useful when a nested rule is desired.)
    </p>

    <p>
      The interpolation function sets the location of the data points in each dimension
      using the Clenshaw Curtis rule, that is, using the N extrema of
      the Chebyshev polynomial of the first kind of order N-1.  Those
      polynomials are defined on [-1,+1], but a simple linear mapping
      is used to adjust the points to the interval specified by the user.
    </p>

    <p>
      The interpolation function needs data at the data points.  It is assumed that this
      will be supplied by a user specified function of the form
      <pre>
        v = f ( m, n, x )
      </pre>
      where M is the spatial dimension, N is the number of points to be
      evaluated, X is a vector of dimension (M,N) containing the points,
      and the result is the vector V of dimension (N) containing the function
      values.
    </p>

    <p>
      Typical usage involves several steps.  
      The size of the interpolant grid is determined by a call like:
      <pre>
        nd = lagrange_interp_nd_size ( m, ind );
      </pre>
      Then the interpolant grid is determined by
      <pre>
        xd = lagrange_interp_nd_grid ( m, ind, ab, nd );
      </pre>
      and the interpolant data is evaluated by
      <pre>
        zd = f ( m, nd, xd );
      </pre>
      Once the interpolant has been defined, the user is free to evaluate
      it repeatedly, by specifying NI points XI, and requesting the interpolated
      values ZI by:
      <pre>
        zi = lagrange_interp_nd_value ( m, ind, ab, nd, zd, ni, xi );
      </pre>
    </p>

    <p>
      LAGRANGE_INTERP_ND needs the R8LIB library.
    </p>

    <h3 align = "center">
      Licensing:
    </h3>

    <p>
      The computer code and data files described and made available on this web page
      are distributed under
      <a href = "https://www.gnu.org/licenses/lgpl-3.0.en.html">the GNU LGPL license.</a>
    </p>

    <h3 align = "center">
      Languages:
    </h3>

    <p>
      <b>lagrange_interp_nd</b> is available in
      <a href = "../../c_src/lagrange_interp_nd/lagrange_interp_nd.html">a C version</a> and
      <a href = "../../cpp_src/lagrange_interp_nd/lagrange_interp_nd.html">a C++ version</a> and
      <a href = "../../f_src/lagrange_interp_nd/lagrange_interp_nd.html">a FORTRAN90 version</a> and
      <a href = "../../m_src/lagrange_interp_nd/lagrange_interp_nd.html">a MATLAB version</a>.
    </p>

    <h3 align = "center">
      Related Data and Programs:
    </h3>

    <p>
      <a href = "../../m_src/lagrange_interp_1d/lagrange_interp_1d.html">
      lagrange_interp_1d</a>,
      a MATLAB code which
      defines and evaluates the Lagrange polynomial p(x) 
      which interpolates a set of data, so that p(x(i)) = y(i).
    </p>

    <p>
      <a href = "../../m_src/lagrange_interp_2d/lagrange_interp_2d.html">
      lagrange_interp_2d</a>,
      a MATLAB code which
      defines and evaluates the Lagrange polynomial p(x,y) 
      which interpolates a set of data depending on a 2D argument
      that was evaluated on a product grid,
      so that p(x(i),y(j)) = z(i,j).
    </p>

    <p>
      <a href = "../../m_src/lagrange_interp_nd_test/lagrange_interp_nd_test.html">
      lagrange_interp_nd_test</a>
    </p>

    <p>
      <a href = "../../m_src/r8lib/r8lib.html">
      r8lib</a>,
      a MATLAB code which
      contains many utility routines using double precision real (R8) arithmetic.
    </p>

    <p>
      <a href = "../../m_src/rbf_interp_nd/rbf_interp_nd.html">
      rbf_interp_nd</a>,
      a MATLAB code which
      defines and evaluates radial basis function (RBF) interpolants to multidimensional data.
    </p>

    <p>
      <a href = "../../m_src/shepard_interp_nd/shepard_interp_nd.html">
      shepard_interp_nd</a>,
      a MATLAB code which
      defines and evaluates Shepard interpolants to multidimensional data,
      based on inverse distance weighting.
    </p>

    <p>
      <a href = "../../m_src/sparse_interp_nd/sparse_interp_nd.html">
      sparse_interp_nd</a>
      a MATLAB code which
      can be used to define a sparse interpolant to a function f(x) of a 
      multidimensional argument.
    </p>

    <p>
      <a href = "../../m_src/spinterp/spinterp.html">
      spinterp</a>,
      a MATLAB code which
      carries out piecewise multilinear hierarchical sparse grid interpolation;
      an earlier version of this software is ACM TOMS Algorithm 847,
      by Andreas Klimke;
    </p>

    <p>
      <a href = "../../m_src/test_interp_nd/test_interp_nd.html">
      test_interp_nd</a>,
      a MATLAB code which
      defines test problems for interpolation of data z(x),
      depending on an M-dimensional argument.
    </p>

    <h3 align = "center">
      Reference:
    </h3>

    <p>
      <ol>
        <li>
          Philip Davis,<br>
          Interpolation and Approximation,<br>
          Dover, 1975,<br>
          ISBN: 0-486-62495-1,<br>
          LC: QA221.D33
        </li>
      </ol>
    </p>

    <h3 align = "center">
      Source Code:
    </h3>

    <p>
      <ul>
        <li>
          <a href = "cc_compute_points.m">cc_compute_points.m</a>,
          computes the Clenshaw Curtis points.
        </li>
        <li>
          <a href = "lagrange_basis_1d.m">lagrange_basis_1d.m</a>,
          evaluates a 1D Lagrange basis.
        </li>
        <li>
          <a href = "lagrange_interp_nd_grid.m">lagrange_interp_nd_grid.m</a>,
          sets an M-dimensional Lagrange interpolant grid.
        </li>
        <li>
          <a href = "lagrange_interp_nd_grid2.m">lagrange_interp_nd_grid2.m</a>,
          sets an M-dimensional Lagrange interpolant grid, using levels instead of orders.
        </li>
        <li>
          <a href = "lagrange_interp_nd_size.m">lagrange_interp_nd_size.m</a>,
          sizes an M-dimensional Lagrange interpolant grid.
        </li>
        <li>
          <a href = "lagrange_interp_nd_size2.m">lagrange_interp_nd_size2.m</a>,
          sizes an M-dimensional Lagrange interpolant grid, using levels instead of orders.
        </li>
        <li>
          <a href = "lagrange_interp_nd_value.m">lagrange_interp_nd_value.m</a>,
          evaluates an M-dimensional Lagrange interpolant.
        </li>
        <li>
          <a href = "lagrange_interp_nd_value2.m">lagrange_interp_nd_value2.m</a>,
          evaluates an M-dimensional Lagrange interpolant, using levels 
          instead of orders.
        </li>
        <li>
          <a href = "order_from_level_135.m">order_from_level_135.m</a>,
          evaluates the 135 level-to-order relationship.
        </li>
      </ul>
    </p>

    <hr>

    <i>
      Last modified on 07 February 2019.
    </i>

    <!-- John Burkardt -->

  </body>

</html>

