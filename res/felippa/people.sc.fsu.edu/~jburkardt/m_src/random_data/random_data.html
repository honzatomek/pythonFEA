<html>

  <head>
    <title>
      random_data
    </title>
  </head>

  <body bgcolor="#EEEEEE" link="#CC0000" alink="#FF3300" vlink="#000055">

    <h1 align = "center">
      random_data
    </h1>

    <hr>

    <p>
      <b>random_data</b>,
      a MATLAB code which 
      uses a random number generator (RNG) to sample points for
      various probability distributions, spatial dimensions, and geometries,
      including the M-dimensional cube, ellipsoid, simplex and sphere. 
    </p>

    <p>
      Most of these routines assume that there is an available source
      of pseudorandom numbers, distributed uniformly in the unit
      interval [0,1].  In this package, that role is played by the
      routine R8_UNIFORM_01(), which allows us some portability.  
      We can get the same results in C, FORTRAN or MATLAB, for instance.
      In general, however, it would be more efficient to use the
      language-specific random number generator for this purpose.
    </p>

    <p>
      If we have a source of pseudorandom values in [0,1], it's trivial 
      to generate pseudorandom points in any line segment; it's easy to 
      take pairs of pseudorandom values to sample a square, or triples to 
      sample a cube.  It's easy to see how to deal with square region that
      is translated from the origin, or scaled by different amounts in
      either axis, or given a rigid rotation.  The same simple transformations
      can be applied to higher dimensional cubes, without giving us any
      concern.
    </p>

    <p>
      For all these simple shapes, which are just generalizations of 
      a square, we can easily see how to generate sample points that
      we can guarantee will lie inside the region; in most cases, we
      can also guarantee that these points will tend to be <i>uniformly
      distributed</i>, that is, every subregion can expect to contain 
      a number of points proportional to its share of the total area. 
    </p>

    <p>
      However, we will <b>not</b> achieve uniform distribution in the
      simple case of a rectangle of nonequal sides <b>[0,A]</b> x <b>[0,B]</b>,
      if we naively scale the random values <b>(u1,u2)</b> to 
      <b>(A*u1,B*u2)</b>.  In that case, the expected point density of
      a wide, short region will differ from that of a narrow tall region.
      The absence of uniformity is most obvious if the points are plotted.
    </p>

    <p>
      If you realize that uniformity is desirable, and easily lost,
      it is possible to adjust the approach so that rectangles are
      properly handled.
    </p>

    <p>
      But rectangles are much too simple.  We are interested in circles,
      triangles, and other shapes.  Once the geometry of the region 
      becomes more "interesting", there are two common ways to continue.  
    </p>

    <p>
      In the <i>acceptance-rejection method</i>, 
      uniform points are generated in a superregion that encloses the 
      region.  Then, points that do not lie within the region are rejected. 
      More points are generated until enough have been accepted to satisfy the 
      needs.  If a circle was the region of interest, for instance, we
      could surround it with a box, generate points in the box, and throw
      away those points that don't actually lie in the circle.  The resulting
      set of samples will be a uniform sampling of the circle.
    </p>

    <p>
      In the <i>direct mapping</i> method, a formula or mapping
      is determined so that each time a set of values is taken from
      the pseudorandom number generator, it is guaranteed to correspond
      to a point in the region.  For the circle problem, we can use
      one uniform random number to choose an angle between 0 and 2 PI,
      the other to choose a radius.  (The radius must be chosen in
      an appropriate way to guarantee uniformity, however.)  Thus,
      every time we input two uniform random values, we get a pair
      (R,T) that corresponds to a point in the circle.
    </p>
 
    <p>
      The acceptance-rejection method can be simple to program, and 
      can handle arbitrary regions.  The direct mapping method is 
      less sensitive to variations in the aspect ratio of a region 
      and other irregularities.  However, direct mappings are only 
      known for certain common mathematical shapes.
    </p>

    <p>
      Points may also be generated according to a nonuniform density.
      This creates an additional complication in programming.  However,
      there are some cases in which it is possible to use direct mapping
      to turn a stream of scalar uniform random values into a set of
      multivariate data that is governed by a normal distribution.
    </p>

    <p>
      Another way to generate points replaces the uniform pseudorandom number
      generator by a <i>quasirandom number generator</i>.  The main difference
      is that successive elements of a quasirandom sequence may be highly
      correlated (bad for certain Monte Carlo applications) but will tend
      to cover the region in a much more regular way than pseudorandom
      numbers.  Any process that uses uniform random numbers to carry out
      sampling can easily be modified to do the same sampling with
      a quasirandom sequence like the Halton sequence, for instance.
    </p>

    <p>
      The library includes a routine that can write the resulting 
      data points to a file.
    </p>

    <h3 align = "center">
      Licensing:
    </h3>

    <p>
      The computer code and data files made available on this web page 
      are distributed under
      <a href = "https://www.gnu.org/licenses/lgpl-3.0.en.html">the GNU LGPL license.</a>
    </p>

    <h3 align = "center">
      Languages:
    </h3>

    <p>
      <b>random_data</b> is available in
      <a href = "../../c_src/random_data/random_data.html">a C version</a> and
      <a href = "../../cpp_src/random_data/random_data.html">a C++ version</a> and
      <a href = "../../f_src/random_data/random_data.html">a FORTRAN90 version</a> and
      <a href = "../../m_src/random_data/random_data.html">a MATLAB version</a> and
      <a href = "../../py_src/random_data/random_data.html">a Python version</a>. 
    </p>

    <h3 align = "center">
      Related Data and Programs:
    </h3>

    <p>
      <a href = "../../m_src/random_data_test/random_data_test.html">
      random_data_test</a>
    </p>

    <p>
      <a href = "../../m_src/asa183/asa183.html">
      asa183</a>,
      a MATLAB code which
      implements the Wichman-Hill pseudorandom number generator.
    </p>

    <p>
      <a href = "../../m_src/ball_grid/ball_grid.html">
      ball_grid</a>, 
      a MATLAB code which 
      computes grid points that lie inside a ball.
    </p>

    <p>
      <a href = "../../m_src/disk_grid/disk_grid.html">
      disk_grid</a>, 
      a MATLAB code which 
      computes grid points that lie inside a disk.
    </p>

    <p>
      <a href = "../../m_src/histogram_data_2d_sample/histogram_data_2d_sample.html">
      histogram_data_2d_sample</a>,
      a MATLAB code which
      demonstrates how to construct a Probability Density Function (PDF)
      from a frequency table over a 2D domain, and then to use that PDF 
      to create new samples.
    </p>

    <p>
      <a href = "../../m_src/histogram_pdf_sample/histogram_pdf_sample.html">
      histogram_pdf_sample</a>,
      a MATLAB code which
      demonstrates how sampling can be done by starting with the
      formula for a PDF, creating a histogram, constructing a
      histogram for the CDF, and then sampling.
    </p>

    <p>
      <a href = "../../m_src/histogram_pdf_2d_sample/histogram_pdf_2d_sample.html">
      histogram_pdf_2d_sample</a>,
      a MATLAB code which
      demonstrates how uniform sampling of a 2D region with respect to some
      known Probability Density Function (PDF) can be approximated by 
      decomposing the region into rectangles, approximating the PDF by
      a piecewise constant function, constructing a histogram for the CDF, 
      and then sampling.
    </p>

    <p>
      <a href = "../../m_src/ring_data/ring_data.html">
      ring_data</a> ,
      a MATLAB code which 
      creates, plots, or saves data generated by sampling a number of
      concentric, possibly overlapping rings.
    </p>

    <p>
      <a href = "../../m_src/sammon_data/sammon_data.html">
      sammon_data</a>,
      a MATLAB code which
      generates six sets of M-dimensional data for cluster analysis.
    </p>

    <p>
      <a href = "../../m_src/simplex_coordinates/simplex_coordinates.html">
      simplex_coordinates</a>, 
      a MATLAB code which
      computes the Cartesian coordinates of the vertices of a regular
      simplex in M dimensions.
    </p>

    <p>
      <a href = "../../m_src/tetrahedron_grid/tetrahedron_grid.html">
      tetrahedron_grid</a>, 
      a MATLAB code which 
      computes a tetrahedral grid of points.
    </p>

    <p>
      <a href = "../../m_src/tetrahedron_monte_carlo/tetrahedron_monte_carlo.html">
      tetrahedron_monte_carlo</a>, 
      a MATLAB code which 
      uses the Monte Carlo method to estimate integrals over a tetrahedron.
    </p>

    <p>
      <a href = "../../datasets/tetrahedron_samples/tetrahedron_samples.html">
      tetrahedron_samples</a>, 
      a dataset directory which 
      contains examples of sets of sample points from the unit tetrahedron.
    </p>

    <p>
      <a href = "../../m_src/triangle_grid/triangle_grid.html">
      triangle_grid</a>, 
      a MATLAB code which 
      computes a triangular grid of points.
    </p>

    <p>
      <a href = "../../m_src/triangle_histogram/triangle_histogram.html">
      triangle_histogram</a>, 
      a MATLAB code which 
      computes histograms of data on the unit triangle.
    </p>

    <p>
      <a href = "../../m_src/triangle_monte_carlo/triangle_monte_carlo.html">
      triangle_monte_carlo</a>, 
      a MATLAB code which 
      uses the Monte Carlo method to estimate integrals over a triangle.
    </p>

    <p>
      <a href = "../../datasets/triangle_samples/triangle_samples.html">
      triangle_samples</a>, 
      a dataset directory which 
      contains examples of sets of sample points from the unit triangle.
    </p>

    <p>
      <a href = "../../m_src/uniform/uniform.html">
      uniform</a>, 
      a MATLAB code which
      samples the uniform random distribution.
    </p>

    <h3 align = "center">
      Source Code:
    </h3>

    <p>
      <ul>
        <li>
          <a href = "brownian.m">brownian.m</a>
          creates Brownian motion points.
        </li>
        <li>
          <a href = "dpo_fa.m">dpo_fa.m</a>
          factors a real symmetric positive definite matrix.
        </li>
        <li>
          <a href = "dpo_sl.m">dpo_sl.m</a>
          solves a linear system factored by DPO_CO or DPO_FA.
        </li>
        <li>
          <a href = "direction_uniform_nd.m">direction_uniform_nd.m</a>
          generates a random direction vector.
        </li>
        <li>
          <a href = "ksub_random2.m">ksub_random2.m</a>
          selects a random subset of size K from a set of size N.
        </li>
        <li>
          <a href = "normal_circular.m">normal_circular.m</a>
          creates circularly normal points.
        </li>
        <li>
          <a href = "normal_square.m">normal_square.m</a>
          creates normally distributed points.
        </li>
        <li>
          <a href = "polygon_centroid.m">polygon_centroid.m</a>
          computes the centroid of a polygon.
        </li>
        <li>
          <a href = "stri_angles_to_area.m">
          stri_angles_to_area.m</a>, 
          computes the area of a spherical triangle;
        </li>
        <li>
          <a href = "stri_sides_to_angles.m">
          stri_sides_to_angles.m</a>, 
          computes the angles of a spherical triangle from its sides;
        </li>
        <li>
          <a href = "stri_vertices_to_sides.m">
          stri_vertices_to_sides.m</a>, 
          computes the sides of a spherical triangle from its sides;
        </li>
        <li>
          <a href = "triangle_area.m">triangle_area.m</a>
          computes the area of a triangle.
        </li>
        <li>
          <a href = "uniform_in_annulus.m">uniform_in_annulus.m</a>
          returns uniform random points inside an annulus.
        </li>
        <li>
          <a href = "uniform_in_annulus_sector.m">uniform_in_annulus_sector.m</a>
          returns uniform random points inside an annular sector.
        </li>
        <li>
          <a href = "uniform_in_circle.m">uniform_in_circle.m</a>
          returns uniform random points inside the unit circle.
        </li>
        <li>
          <a href = "uniform_in_ellipse.m">uniform_in_ellipse.m</a>
          returns uniform random points inside an ellipse.
        </li>
        <li>
          <a href = "uniform_in_ellipsoid.m">uniform_in_ellipsoid.m</a>
          returns uniform random points inside an ellipsoid.
        </li>
        <li>
          <a href = "uniform_in_hexagon.m">uniform_in_hexagon.m</a>
          returns uniform random points inside a unit hexagon.
        </li>
        <li>
          <a href = "uniform_in_hypercube.m">uniform_in_hypercube.m</a>
          returns uniform random points inside the unit hypercube.
        </li>
        <li>
          <a href = "uniform_in_hypersphere.m">uniform_in_hypersphere.m</a>
          returns uniform random points inside the unit hypersphere.
        </li>
        <li>
          <a href = "uniform_in_parallelogram.m">
          uniform_in_parallelogram.m</a>
          returns uniform random points inside a parallelogram.
        </li>
        <li>
          <a href = "uniform_in_polygon.m">uniform_in_polygon.m</a>
          returns uniform random points inside a polygon.
        </li>
        <li>
          <a href = "uniform_in_sector.m">uniform_in_sector.m</a>
          returns uniform random points inside a circular sector.
        </li>
        <li>
          <a href = "uniform_in_simplex.m">uniform_in_simplex.m</a>
          returns uniform random points inside the unit simplex.
        </li>
        <li>
          <a href = "uniform_in_tetrahedron.m">uniform_in_tetrahedron.m</a>
          returns uniform random points inside a tetrahedron.
        </li>
        <li>
          <a href = "uniform_in_triangle.m">
          uniform_in_triangle.m</a>
          returns uniform random points inside an arbitrary triangle.
        </li>
        <li>
          <a href = "uniform_on_circle.m">uniform_on_circle.m</a>
          returns uniform random points on the surface of a circle. 
        </li>
        <li>
          <a href = "uniform_on_ellipse.m">uniform_on_ellipse.m</a>
          returns uniform random points on the surface of an ellipse. 
        </li>
        <li>
          <a href = "uniform_on_ellipsoid.m">uniform_on_ellipsoid.m</a>
          returns uniform random points on the surface of an ellipsoid. 
        </li>
        <li>
          <a href = "uniform_on_hemisphere_phong.m">
          uniform_on_hemisphere_phong.m</a>
          returns uniform random points on the surface of the unit 
          hemisphere, with the Phong distribution.
        </li>
        <li>
          <a href = "uniform_on_hypercube.m">uniform_on_hypercube.m</a>
          returns uniform random points on the surface of the unit hypercube. 
        </li>
        <li>
          <a href = "uniform_on_hypersphere.m">uniform_on_hypersphere.m</a>
          returns uniform random points on the surface of the unit hypersphere.
        </li>
        <li>
          <a href = "uniform_on_simplex.m">uniform_on_simplex.m</a>
          returns uniform random points on the surface of the unit simplex.
        </li>
        <li>
          <a href = "uniform_on_sphere_patch_tp.m">
          uniform_on_sphere_patch_tp.m</a>
          returns uniform random points on the surface of a unit sphere 
          (THETA,PHI) patch in 3D.
        </li>
        <li>
          <a href = "uniform_on_sphere_patch_xyz.m">
          uniform_on_sphere_patch_xyz.m</a>
          returns uniform random points on the surface of a unit sphere 
          XYZ patch in 3D.
        </li>
        <li>
          <a href = "uniform_on_sphere_triangle_xyz.m">
          uniform_on_sphere_triangle_xyz.m</a>
          returns uniform random points on the surface of a spherical 
          triangle on the unit sphere, using
          XYZ coordinates.
        </li>
        <li>
          <a href = "uniform_on_triangle.m">uniform_on_triangle.m</a>
          returns uniform random points on the surface of a triangle.
        </li>
        <li>
          <a href = "uniform_walk.m">uniform_walk.m</a>
          generates points on a uniform random walk.
        </li>
      </ul>
    </p>

    <hr>

    <i>
      Last revised on 13 April 2022.
    </i>

    <!-- John Burkardt -->
 
  </body>

</html>
